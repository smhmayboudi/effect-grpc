---
title: Accumulate Multiple Errors with Either
id: data-either
skillLevel: beginner
useCase: domain-modeling
summary: >-
  Use Either<E, A> to represent computations that can fail, allowing you to
  accumulate multiple errors instead of short-circuiting on the first one.
tags:
  - Either
  - error-handling
  - data-type
  - domain
  - effect
rule:
  description: >-
    Use Either to model computations that may fail, making errors explicit and
    type-safe.
related:
  - data-option
  - data-cause
author: PaulJPhilp
---

# Accumulate Multiple Errors with `Either`

## Guideline

Use the `Either<E, A>` data type to represent computations that can fail (`Left<E>`) or succeed (`Right<A>`).  
This makes error handling explicit, type-safe, and composable.

## Rationale

`Either` is a foundational data type for error handling in functional programming.  
It allows you to accumulate errors, model domain-specific failures, and avoid exceptions and unchecked errors.

## Good Example

```typescript
import { Either } from "effect";

// Create a Right (success) or Left (failure)
const success = Either.right(42); // Either<never, number>
const failure = Either.left("Something went wrong"); // Either<string, never>

// Pattern match on Either
const result = success.pipe(
  Either.match({
    onLeft: (err) => `Error: ${err}`,
    onRight: (value) => `Value: ${value}`,
  })
); // string

// Combine multiple Eithers and accumulate errors
const e1 = Either.right(1);
const e2 = Either.left("fail1");
const e3 = Either.left("fail2");

const all = Either.all([e1, e2, e3]); // Either<string, [number, never, never]>
const rights = [e1, e2, e3].filter(Either.isRight); // Right values only
const lefts = [e1, e2, e3].filter(Either.isLeft); // Left values only

```

**Explanation:**  
- `Either.right(value)` represents success.
- `Either.left(error)` represents failure.
- Pattern matching ensures all cases are handled.
- You can accumulate errors or results from multiple Eithers.

## Anti-Pattern

Throwing exceptions or using ad-hoc error codes, which are not type-safe, not composable, and make error handling less predictable.
