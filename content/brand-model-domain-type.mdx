---
title: Modeling Validated Domain Types with Brand
id: brand-model-domain-type
skillLevel: intermediate
useCase: domain-modeling
summary: >-
  Use Brand to create domain-specific types from primitives, making illegal
  states unrepresentable and preventing accidental misuse.
tags:
  - Brand
  - domain
  - type-safety
  - validation
  - effect
rule:
  description: >-
    Use Brand to define types like Email, UserId, or PositiveInt, ensuring only
    valid values can be constructed and used.
related:
  - brand-validate-parse
author: PaulJPhilp
---

# Modeling Validated Domain Types with `Brand`

## Guideline

Use the `Brand` utility to create domain-specific types from primitives like `string` or `number`.  
This prevents accidental misuse and makes illegal states unrepresentable in your codebase.

## Rationale

Branded types add a layer of type safety, ensuring that values like `Email`, `UserId`, or `PositiveInt` are not confused with plain strings or numbers.  
They help you catch bugs at compile time and make your code more self-documenting.

## Good Example

```typescript
import { Brand } from "effect";

// Define a branded type for Email
type Email = string & Brand.Brand<"Email">;

// Function that only accepts Email, not any string
function sendWelcome(email: Email) {
  // ...
}

// Constructing an Email value (unsafe, see next pattern for validation)
const email = "user@example.com" as Email;

sendWelcome(email); // OK
// sendWelcome("not-an-email"); // Type error! (commented to allow compilation)

```

**Explanation:**  
- `Brand.Branded<T, Name>` creates a new type that is distinct from its base type.
- Only values explicitly branded as `Email` can be used where an `Email` is required.
- This prevents accidental mixing of domain types.

## Anti-Pattern

Using plain strings or numbers for domain-specific values (like emails, user IDs, or currency codes), which can lead to accidental misuse and bugs that are hard to catch.
