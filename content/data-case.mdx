---
title: Modeling Tagged Unions with Data.case
id: data-case
skillLevel: intermediate
useCase: domain-modeling
summary: >-
  Use Data.case to create tagged unions (algebraic data types) for robust,
  type-safe domain modeling and pattern matching.
tags:
  - Data.case
  - tagged-union
  - ADT
  - domain-modeling
  - pattern-matching
  - data-type
  - effect
rule:
  description: >-
    Use Data.case to define tagged unions (ADTs) for modeling domain-specific
    states and enabling exhaustive pattern matching.
related:
  - data-struct
  - pattern-matchtag
author: PaulJPhilp
---

# Modeling Tagged Unions with `Data.case`

## Guideline

Use `Data.case` to create tagged unions (algebraic data types, or ADTs) for robust, type-safe domain modeling.  
Tagged unions make it easy to represent and exhaustively handle all possible states of your domain entities.

## Rationale

Modeling domain logic with tagged unions ensures that all cases are handled, prevents illegal states, and enables safe, exhaustive pattern matching.  
`Data.case` provides a concise, type-safe way to define and use ADTs in your application.

## Good Example

```typescript
import { Data } from "effect";

// Define a tagged union for a simple state machine
type State = Data.TaggedEnum<{
  Loading: {}
  Success: { data: string }
  Failure: { error: string }
}>
const { Loading, Success, Failure } = Data.taggedEnum<State>()

// Create instances
const state1: State = Loading()
const state2: State = Success({ data: "Hello" })
const state3: State = Failure({ error: "Oops" })

// Pattern match on the state
function handleState(state: State): string {
  switch (state._tag) {
    case "Loading":
      return "Loading...";
    case "Success":
      return `Data: ${state.data}`;
    case "Failure":
      return `Error: ${state.error}`;
  }
}
```

**Explanation:**  
- `Data.case` creates tagged constructors for each state.
- The `_tag` property enables exhaustive pattern matching.
- Use for domain modeling, state machines, and error types.

## Anti-Pattern

Using plain objects or enums for domain states, which can lead to illegal states, missed cases, and less type-safe pattern matching.
