---
title: Creating from Collections
id: constructor-from-iterable
skillLevel: beginner
useCase: resource-management
summary: >-
  Use fromIterable and fromArray to create Streams or Effects from arrays,
  iterables, or other collections, enabling batch and streaming operations.
tags:
  - fromIterable
  - fromArray
  - constructor
  - stream
  - effect
  - collection
  - batch
rule:
  description: >-
    Use fromIterable and fromArray to lift collections into Streams or Effects
    for batch or streaming processing.
related:
  - constructor-succeed-some-right
  - constructor-from-nullable-option-either
author: PaulJPhilp
---

# Creating from Collections

## Guideline

Use the `fromIterable` and `fromArray` constructors to create Streams or Effects from arrays, iterables, or other collections.  
This is the foundation for batch processing, streaming, and working with large or dynamic data sources.

## Rationale

Lifting collections into Streams or Effects allows you to process data in a composable, resource-safe, and potentially concurrent way.  
It also enables you to use all of Effect's combinators for transformation, filtering, and error handling.

## Good Example

```typescript
import { Stream, Effect } from "effect";

// Stream: Create a stream from an array
const numbers = [1, 2, 3, 4];
const numberStream = Stream.fromIterable(numbers); // Stream<number>

// Stream: Create a stream from any iterable
function* gen() {
  yield "a";
  yield "b";
}
const letterStream = Stream.fromIterable(gen()); // Stream<string>

// Effect: Create an effect from an array of effects (batch)
const effects = [Effect.succeed(1), Effect.succeed(2)];
const batchEffect = Effect.all(effects); // Effect<[1, 2]>
```

**Explanation:**  
- `Stream.fromIterable` creates a stream from any array or iterable, enabling streaming and batch operations.
- `Effect.all` (covered elsewhere) can be used to process arrays of effects in batch.

## Anti-Pattern

Manually looping over collections and running effects or streams imperatively, which loses composability, error handling, and resource safety.
