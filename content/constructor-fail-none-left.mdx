---
title: 'Lifting Errors and Absence with fail, none, and left'
id: constructor-fail-none-left
skillLevel: beginner
useCase: error-management
summary: >-
  Use fail, none, and left to represent errors or absence in Effect, Option, or
  Either, making failures explicit and type-safe.
tags:
  - fail
  - none
  - left
  - constructor
  - effect
  - option
  - either
  - error
  - absence
rule:
  description: >-
    Use fail, none, and left to create Effect, Option, or Either that represent
    failure or absence.
related:
  - constructor-succeed-some-right
  - constructor-try-trypromise
author: PaulJPhilp
---

# Lifting Errors and Absence with `fail`, `none`, and `left`

## Guideline

Use the `fail`, `none`, and `left` constructors to represent errors or absence in the Effect, Option, or Either world.  
This makes failures explicit, type-safe, and composable.

## Rationale

By lifting errors and absence into these structures, you can handle them declaratively with combinators, rather than relying on exceptions, `null`, or `undefined`.  
This leads to more robust and maintainable code.

## Good Example

```typescript
import { Effect, Option, Either } from "effect";

// Effect: Represent a failure with an error value
const effect = Effect.fail("Something went wrong"); // Effect<string, never, never>

// Option: Represent absence of a value
const option = Option.none(); // Option<never>

// Either: Represent a failure with a left value
const either = Either.left("Invalid input"); // Either<string, never>
```

**Explanation:**  
- `Effect.fail(error)` creates an effect that always fails with `error`.
- `Option.none()` creates an option that is always absent.
- `Either.left(error)` creates an either that always represents failure.

## Anti-Pattern

Throwing exceptions, returning `null` or `undefined`, or using error codes outside the Effect, Option, or Either world.  
This makes error handling ad hoc, less type-safe, and harder to compose.
