---
title: Filtering Results with filter
id: combinator-filter
skillLevel: beginner
useCase: core-concepts
summary: >-
  Use filter to keep or discard results based on a predicate, across Effect,
  Stream, Option, and Either.
tags:
  - filter
  - combinator
  - predicate
  - effect
  - stream
  - option
  - either
rule:
  description: >-
    Use filter to declaratively express conditional logic, keeping only values
    that satisfy a predicate.
related:
  - combinator-map
  - combinator-flatmap
  - combinator-conditional
author: PaulJPhilp
---

# Filtering Results with `filter`

## Guideline

Use the `filter` combinator to keep only those values that satisfy a predicate.  
This works for `Effect`, `Stream`, `Option`, and `Either`, allowing you to express conditional logic declaratively and safely.

## Rationale

`filter` lets you express "only continue if..." logic without resorting to manual checks or imperative branching.  
It keeps your code composable and type-safe, and ensures that failures or empty results are handled consistently.

## Good Example

```typescript
import { Effect, Stream, Option, Either } from "effect";

// Effect: Only succeed if the value is even, fail otherwise
const effect = Effect.succeed(4).pipe(
  Effect.filterOrFail(
    (n): n is number => n % 2 === 0,
    () => "Number is not even"
  )
); // Effect<number, string>

// Option: Only keep the value if it is even
const option = Option.some(4).pipe(
  Option.filter((n): n is number => n % 2 === 0)
); // Option<number>

// Either: Use map and flatMap to filter
const either = Either.right(4).pipe(
  Either.flatMap((n) => 
    n % 2 === 0
      ? Either.right(n)
      : Either.left("Number is not even")
  )
); // Either<string, number>

// Stream: Only emit even numbers
const stream = Stream.fromIterable([1, 2, 3, 4]).pipe(
  Stream.filter((n): n is number => n % 2 === 0)
); // Stream<number>
```

**Explanation:**  
`filter` applies a predicate to the value(s) inside the structure. If the predicate fails, the result is a failure (`Effect.fail`, `Either.left`), `Option.none`, or an empty stream.

## Anti-Pattern

Using `map` with a conditional that returns `Option` or `Either`, then manually flattening, instead of using `filter`.  
This leads to unnecessary complexity and less readable code.
